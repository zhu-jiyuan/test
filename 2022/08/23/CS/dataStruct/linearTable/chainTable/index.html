<!-- build time:Thu Sep 01 2022 15:15:48 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="//cdn.jsdelivr.net/gh/zhu-jiyuan/zhu-jiyuan.github.io@latest/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="//cdn.jsdelivr.net/gh/zhu-jiyuan/zhu-jiyuan.github.io@latest/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="北纬23" href="https://blog.ohayo.live/rss.xml"><link rel="alternate" type="application/atom+xml" title="北纬23" href="https://blog.ohayo.live/atom.xml"><link rel="alternate" type="application/json" title="北纬23" href="https://blog.ohayo.live/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/zhu-jiyuan/zhu-jiyuan.github.io@latest/css/app.css?v=0.2.5"><meta name="keywords" content="note"><link rel="canonical" href="https://blog.ohayo.live/2022/08/23/CS/dataStruct/linearTable/chainTable/"><title>数据结构-链表 - 数据结构 - CS | Gloria's notion = 北纬23 = 千呼万唤始出来</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">数据结构-链表</h1><div class="meta"><span class="item" title="创建时间：2022-08-23 16:05:11"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-08-23T16:05:11+08:00">2022-08-23</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>6.5k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>6 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Gloria's notion</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giclgi503lj20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giclxfdlttj20zk0m8npd.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gicitzannuj20zk0m8b29.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gicitcxhpij20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipeuv80yoj20zk0m8kjl.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giclwuom7cj20zk0m8dvn.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CS/" itemprop="item" rel="index" title="分类于 CS"><span itemprop="name">CS</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CS/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="item" rel="index" title="分类于 数据结构"><span itemprop="name">数据结构</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://blog.ohayo.live/2022/08/23/CS/dataStruct/linearTable/chainTable/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="//cdn.jsdelivr.net/gh/zhu-jiyuan/zhu-jiyuan.github.io@latest/images/avatar.jpg"><meta itemprop="name" content="Gloria"><meta itemprop="description" content="千呼万唤始出来, 满怀勇敢"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="北纬23"></span><div class="body md" itemprop="articleBody"><h1 id="笨蛋链表_"><a class="anchor" href="#笨蛋链表_">#</a> <span class="pink">笨蛋链表 &gt;_&lt;</span></h1><p>链表有很多种类</p><ol><li>单链表</li><li>双向链表</li><li>循环链表<ol><li>单向</li><li>双向</li></ol></li><li>静态链表（利用数组实现的）</li></ol><p><img data-src="https://s2.loli.net/2022/08/23/Xt5caNR8fiOIumJ.png" alt="image-20220823164418192"></p><p>静态链表的实现如下</p><p>0-&gt;3-&gt;2-&gt;1-&gt;-1 (以 - 1 结尾)</p><table><thead><tr><th>index</th><th>data</th><th>next</th></tr></thead><tbody><tr><td>0</td><td>7213</td><td>3</td></tr><tr><td>1</td><td>321</td><td>-1</td></tr><tr><td>2</td><td>34</td><td>1</td></tr><tr><td>3</td><td>141</td><td>2</td></tr></tbody></table><h1 id="链表的基本操作待补充️"><a class="anchor" href="#链表的基本操作待补充️">#</a> 链表的基本操作 (待补充✏️</h1><p><span class="spoiler" title="你知道得太多了">这是私人领地</span> :<span class="rainbow"> 你不要过来啊～</span></p><h1 id="链表的练习题"><a class="anchor" href="#链表的练习题">#</a> <span class="red">链表的练习题</span></h1><h2 id="考研四连之勤俭节约"><a class="anchor" href="#考研四连之勤俭节约">#</a> 考研四连之勤俭节约</h2><ol><li>已知一个带有表头的单链表，结点结构为 data-link，假设该链表只给出了头指针 list。在 <code>不改变链表的前提下</code> ，请设计一个尽可能高效的算法，查找链表中倒数第 k 个位置上的结点（k 为正整数）。若查找成功，算法输出该结点的 data 域的值，并返回 1，否则，只返回 0。</li></ol><p>data-link 如下：</p><table><thead><tr><th>data</th><th>link</th></tr></thead></table><p>要求：<br>1、给出算法的基本设计思想</p><p>2、根据设计思想，采用 C 或 C++ 或 Java 语言描述算法，关键之处给出注释</p><p>3、说明你所涉及算法的时间复杂度和空间复杂度</p><p></p><div class="links"><div class="item" title="leetcode" style="--block-color:#e9546b"><span class="exturl image" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9saWFuLWJpYW8temhvbmctZGFvLXNodS1kaS1rZ2UtamllLWRpYW4tbGNvZi8=" data-background-image="//cdn.jsdelivr.net/gh/zhu-jiyuan/zhu-jiyuan.github.io@latest/images/404.png"></span><div class="info"><span class="exturl title" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9saWFuLWJpYW8temhvbmctZGFvLXNodS1kaS1rZ2UtamllLWRpYW4tbGNvZi8=">leetcode</span><p class="desc">leetcode传送门</p></div></div></div><p></p><details class="primary"><summary>答案</summary><div><p>方法一： 双指针</p><p>因为只需要遍历一遍即可，时间复杂度 O (n)<br>只需要两个指针，常量大小，空间复杂度 O (1)</p><p>思路：<br>1、定义两个指针 <code>p1、p2</code><br>2、先让 p1 走 k 步，这样 p1 和 p2 之间相差 k 个结点。<br>3、让 P1、p2 一起走，当 p1 走到尽头时，因为 P2 和 p1 相差 k 个结点，p2 正好是倒数第 k 个结点。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num="2"></td><td><pre> * Definition for singly-linked list.</pre></td></tr><tr><td data-num="3"></td><td><pre> * struct ListNode &#123;</pre></td></tr><tr><td data-num="4"></td><td><pre> *     int val;</pre></td></tr><tr><td data-num="5"></td><td><pre> *     ListNode *next;</pre></td></tr><tr><td data-num="6"></td><td><pre> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</pre></td></tr><tr><td data-num="7"></td><td><pre> * &#125;;</pre></td></tr><tr><td data-num="8"></td><td><pre> */</pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    ListNode<span class="token operator">*</span> <span class="token function">getKthFromEnd</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token comment">// 双指针</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        ListNode<span class="token operator">*</span> p1<span class="token punctuation">,</span><span class="token operator">*</span>p2<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        p1 <span class="token operator">=</span> head<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        p2 <span class="token operator">=</span> head<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token comment">// 先让 p1 走 k 次，再让 p1,p2 一起走，直到 p1 走到头为止</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>k<span class="token operator">&amp;&amp;</span>p1<span class="token operator">!=</span><span class="token keyword">nullptr</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            p1<span class="token operator">=</span>p1<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token comment">// 如果 p1 走了 k 走到头了，其实就是返回倒数第一个，即 p2</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token keyword">if</span><span class="token punctuation">(</span>p1<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token keyword">return</span> p2<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token comment">// 如果 p1 没走到头，因为 P2 和 p1 相差 k 个结点，P1、p2 一起走，当 p1 走到尽头时，p2 正好是倒数第 k 个结点。</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token keyword">while</span><span class="token punctuation">(</span>p1<span class="token operator">!=</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>            p1<span class="token operator">=</span>p1<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>            p2 <span class="token operator">=</span> p2<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token keyword">return</span> p2<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>方法二<br>先算出链表长度，然后再从 head 结点开始，走 n-k 个结点</p><p>由于走了，n + n-k 次所以时间复杂度为 O (n)<br>空间复杂度 O (1)</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    ListNode<span class="token operator">*</span> <span class="token function">getKthFromEnd</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">int</span> n<span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token comment">// 先算出链表长度，然后再从 head 结点开始，走 n-k 个结点</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        ListNode<span class="token operator">*</span> t <span class="token operator">=</span> head<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">while</span><span class="token punctuation">(</span>t<span class="token operator">!=</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            n<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            t<span class="token operator">=</span>t<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token operator">-</span>k<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            head<span class="token operator">=</span>head<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">return</span> head<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure></div></details><ol start="2"><li>假定采用带头结点的单链表保存单词，当两个单词有 <code>相同的后缀</code> 时，则可共享相同的后缀存储空间，例如，“loading” 和 “ being ” 的存储映像如下图所示。设 str1 和 str2 分别指向两个单词所在单链表的头结点，链表结点结构为 ，请设计一个 <code>时间上尽可能高效</code> 的算法，找出由 str1 和 str2 所指向两个链表 <code>共同后缀的起始位置</code> （如图中字符 i 所在结点的位置 p ）。</li></ol><p><img data-src="https://s2.loli.net/2022/08/23/WiP6Rb4dpMl2zwf.png" alt="img"></p><p>要求：<br>1、给出算法的基本设计思想</p><p>2、根据设计思想，采用 C 或 C++ 或 Java 语言描述算法，关键之处给出注释</p><p>3、说明你所涉及算法的时间复杂度</p><p></p><div class="links"><div class="item" title="leetcode" style="--block-color:#E9967A"><span class="exturl image" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9saWFuZy1nZS1saWFuLWJpYW8tZGUtZGkteWktZ2UtZ29uZy1nb25nLWppZS1kaWFuLWxjb2Yv" data-background-image="//cdn.jsdelivr.net/gh/zhu-jiyuan/zhu-jiyuan.github.io@latest/images/404.png"></span><div class="info"><span class="exturl title" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9saWFuZy1nZS1saWFuLWJpYW8tZGUtZGkteWktZ2UtZ29uZy1nb25nLWppZS1kaWFuLWxjb2Yv">leetcode</span><p class="desc">leetcode传送门</p></div></div></div><p></p><details class="primary"><summary>答案</summary><div><p>方法一 哈希表<br>我们可以用哈希表，将一个链表的各个结点的<span class="red">地址</span>记录下来。<br>再遍历另外一个链表的结点地址，当找到第一个时，即地址相等，就是公共部分的第一个结点了。<br>时间复杂度 O (m+n)，空间复杂度（n or m）</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    ListNode <span class="token operator">*</span><span class="token function">getIntersectionNode</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span>headA<span class="token punctuation">,</span> ListNode <span class="token operator">*</span>headB<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        unordered_map<span class="token operator">&lt;</span>ListNode<span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">bool</span><span class="token operator">></span>hash<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">while</span><span class="token punctuation">(</span>headA<span class="token operator">!=</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            hash<span class="token punctuation">[</span>headA<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            headA<span class="token operator">=</span>headA<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">while</span><span class="token punctuation">(</span>headB<span class="token operator">!=</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">if</span><span class="token punctuation">(</span>hash<span class="token punctuation">[</span>headB<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                <span class="token keyword">return</span> headB<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            headB<span class="token operator">=</span>headB<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">return</span> headB<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token comment">// 另外也可以用 hashset 实现</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    ListNode <span class="token operator">*</span><span class="token function">getIntersectionNode</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span>headA<span class="token punctuation">,</span> ListNode <span class="token operator">*</span>headB<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        unordered_set<span class="token operator">&lt;</span>ListNode<span class="token operator">*</span><span class="token operator">></span> hash<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token keyword">while</span><span class="token punctuation">(</span>headA<span class="token operator">!=</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>            hash<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>headA<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>            headA<span class="token operator">=</span>headA<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token keyword">while</span><span class="token punctuation">(</span>headB<span class="token operator">!=</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>            <span class="token keyword">if</span><span class="token punctuation">(</span>hash<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>headB<span class="token punctuation">)</span><span class="token operator">!=</span>hash<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>                <span class="token keyword">return</span> headB<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>            headB <span class="token operator">=</span> headB<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>        <span class="token keyword">return</span> headB<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="39"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>方法二 双指针</p><p>Example</p><p>head1 -&gt; l -&gt; o -&gt; a -&gt; d -&gt; i -&gt; n -&gt; g</p><p>head2 -&gt; b -&gt; e -&gt; i -&gt; n -&gt; g</p><p>把 head2 的数据放到 head1 后面</p><table><thead><tr><th>结点地址</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr><td>数据</td><td>l</td><td>o</td><td>a</td><td>d</td><td>i</td><td>n</td><td>g</td><td>b</td><td>e</td><td>i</td><td>n</td><td>g</td></tr></tbody></table><p>把 head1 的数据放到 head2 后面</p><table><thead><tr><th>结点地址</th><th>8</th><th>9</th><th>5</th><th>6</th><th>7</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr><td>数据</td><td>b</td><td>e</td><td>i</td><td>n</td><td>g</td><td>l</td><td>o</td><td>a</td><td>d</td><td>i</td><td>n</td><td>g</td></tr></tbody></table><p><ins>比较一下这两串</ins></p><table><thead><tr><th>结点地址</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th><span class="red">5</span></th><th><span class="red">6</span></th><th style="text-align:left"><span class="red">7</span></th></tr></thead><tbody><tr><td>数据一</td><td>l</td><td>o</td><td>a</td><td>d</td><td>i</td><td>n</td><td>g</td><td>b</td><td>e</td><td><span class="red">i</span></td><td><span class="red">n</span></td><td style="text-align:left"><span class="red">g</span></td></tr><tr><td>结点地址</td><td>8</td><td>9</td><td>10</td><td>11</td><td>12</td><td>1</td><td>2</td><td>3</td><td>4</td><td><span class="red">5</span></td><td><span class="red">6</span></td><td style="text-align:left"><span class="red">7</span></td></tr><tr><td>数据二</td><td>b</td><td>e</td><td>i</td><td>n</td><td>g</td><td>l</td><td>o</td><td>a</td><td>d</td><td><span class="red">i</span></td><td><span class="red">n</span></td><td style="text-align:left"><span class="red">g</span></td></tr></tbody></table><p>这样拼合，最后就可以得到公共的部分了</p><p>1、我们只需用两个指针 <code>pA、pB</code> 分别指向链表 1、链表 2</p><p>2、每次同时移动 <code>pA、pB</code></p><p>3、当 pA=nullptr，即走到链表 1 尽头了，则令 pA = 链表 2 头部，同理 pB=nullptr 时，令 pB = 链表 1 头部。这样就可以实现把 head2 的数据放到 head1 后面（把 head1 的数据放到 head2 后面）的效果啦</p><p>4、当 pA==pB 时，就是公共结点啦。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num="2"></td><td><pre> * Definition for singly-linked list.</pre></td></tr><tr><td data-num="3"></td><td><pre> * struct ListNode &#123;</pre></td></tr><tr><td data-num="4"></td><td><pre> *     int val;</pre></td></tr><tr><td data-num="5"></td><td><pre> *     ListNode *next;</pre></td></tr><tr><td data-num="6"></td><td><pre> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</pre></td></tr><tr><td data-num="7"></td><td><pre> * &#125;;</pre></td></tr><tr><td data-num="8"></td><td><pre> */</pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    ListNode <span class="token operator">*</span><span class="token function">getIntersectionNode</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span>headA<span class="token punctuation">,</span> ListNode <span class="token operator">*</span>headB<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">if</span><span class="token punctuation">(</span>headA<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token operator">||</span>headB<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>        ListNode<span class="token operator">*</span> pA <span class="token operator">=</span> headA<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        ListNode<span class="token operator">*</span> pB <span class="token operator">=</span> headB<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">while</span><span class="token punctuation">(</span>pA<span class="token operator">!=</span>pB<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            pA <span class="token operator">=</span> pA<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            pB <span class="token operator">=</span> pB<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token keyword">if</span><span class="token punctuation">(</span>pA<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token operator">&amp;&amp;</span>pB<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            <span class="token keyword">if</span><span class="token punctuation">(</span>pA<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>pA<span class="token operator">=</span>headB<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token keyword">if</span><span class="token punctuation">(</span>pB<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>pB<span class="token operator">=</span>headA<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token keyword">return</span> pA<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure></div></details><ol start="3"><li>用单链表保存 m 个整数，结点的结构为： <code>[data][link]</code> ，且 | data|≤n（n 为正整数）。现要求设计一个 <code>时间复杂度尽可能高效</code> 的算法，对于链表中 data 的绝对值相等的结点，仅保留第一次出现的结点而删除其余绝对值相等的结点。</li></ol><p>例如，若给定的单链表 head 如下：</p><p><img data-src="https://s2.loli.net/2022/08/23/t1IAa9bx5KRJrZ7.png" alt="img"></p><p>则删除结点后的 head 为：</p><p><img data-src="https://s2.loli.net/2022/08/23/aqr7ePUvQpikmnj.png" alt="img"></p><p>要求：<br>1、给出算法的基本设计思想</p><p>2、使用 c 或 c++ 语言，给出单链表结点的数据类型定义。</p><p>3、根据设计思想，采用 C 或 C++ 描述算法，关键之处给出注释</p><p>4、说明你所涉及算法的时间复杂度和空间复杂度</p><p></p><div class="links"><div class="item" title="leetcode" style="--block-color:#9d5b8b"><span class="exturl image" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZW1vdmUtZHVwbGljYXRlcy1mcm9tLXNvcnRlZC1saXN0Lw==" data-background-image="//cdn.jsdelivr.net/gh/zhu-jiyuan/zhu-jiyuan.github.io@latest/images/404.png"></span><div class="info"><span class="exturl title" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZW1vdmUtZHVwbGljYXRlcy1mcm9tLXNvcnRlZC1saXN0Lw==">leetcode</span><p class="desc">leetcode传送门</p></div></div></div><p></p><details class="primary"><summary>答案</summary><div><p>方法一 哈希表<br>空间复杂度 O（m），时间复杂度 O（n）,m &lt; n.<br>本题要求的是，时间尽可能高效，最容易想到的就是拿空间换时间。<br>1、建立一张 hash 表。<br>2、一边遍历，一边记录已经出现过的绝对值<br>3、在遍历时，先查找当前结点是否在 hash 表中出现过，如果没有出现，则记录到 hash 中，并且插入到链表里。</p><p>用指针 p 表示最后一个插入链表的结点，p2 表示当前结点，用于判断是否插入链表中</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num="2"></td><td><pre> * Definition for singly-linked list.</pre></td></tr><tr><td data-num="3"></td><td><pre> * struct ListNode &#123;</pre></td></tr><tr><td data-num="4"></td><td><pre> *     int val;</pre></td></tr><tr><td data-num="5"></td><td><pre> *     ListNode *next;</pre></td></tr><tr><td data-num="6"></td><td><pre> *     ListNode() : val(0), next(nullptr) &#123;&#125;</pre></td></tr><tr><td data-num="7"></td><td><pre> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</pre></td></tr><tr><td data-num="8"></td><td><pre> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</pre></td></tr><tr><td data-num="9"></td><td><pre> * &#125;;</pre></td></tr><tr><td data-num="10"></td><td><pre> */</pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    ListNode<span class="token operator">*</span> <span class="token function">deleteDuplicates</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token comment">// 特殊情况</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">bool</span><span class="token operator">></span> hash<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>		</pre></td></tr><tr><td data-num="17"></td><td><pre>        ListNode<span class="token operator">*</span> p <span class="token operator">=</span> head<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        ListNode<span class="token operator">*</span> p2 <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        hash<span class="token punctuation">[</span>p<span class="token operator">-></span>val<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token keyword">while</span><span class="token punctuation">(</span>p2<span class="token operator">!=</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        	<span class="token comment">// 如果当前结点没有在 hash 表中，则插入，并且插入链表，让 p 指向该结点</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token keyword">if</span><span class="token punctuation">(</span>hash<span class="token punctuation">[</span>p2<span class="token operator">-></span>val<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>                 hash<span class="token punctuation">[</span>p2<span class="token operator">-></span>val<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>                 p<span class="token operator">-></span>next <span class="token operator">=</span> p2<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>                 p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>            p2 <span class="token operator">=</span> p2<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        <span class="token comment">// 如果 p 最后不是源链表的最后结点，说明 p 后面的元素都在 hash 表中出现过，p 就是最后的结点。所以让 p 的下一个指向 nullptr.</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>next<span class="token operator">!=</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>            p<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        <span class="token keyword">return</span> head<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="35"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>本题是没有说明是排序后的链表，leetcode 上是排序后的.<br>思路大同小异</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    ListNode<span class="token operator">*</span> <span class="token function">deleteDuplicates</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        ListNode<span class="token operator">*</span> p <span class="token operator">=</span> head<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        ListNode<span class="token operator">*</span> p2 <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">while</span><span class="token punctuation">(</span>p2<span class="token operator">!=</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token comment">// 如果没找到</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token keyword">if</span><span class="token punctuation">(</span>p2<span class="token operator">-></span>val<span class="token operator">!=</span>p<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                 p<span class="token operator">-></span>next <span class="token operator">=</span> p2<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                 p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            p2 <span class="token operator">=</span> p2<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>next<span class="token operator">!=</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            p<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token keyword">return</span> head<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure></div></details><ol start="4"><li>设链表 L（a1,a2,a3,…,an-2,an-1,an）采用头结点的单链表保存，请设计一个 <code>空间复杂度为O(1)时间上尽可能高效的算法</code> ，重新排列 L，得到线性表变成（a1,an,a2,an-1,a3,an-2,…）<br>/<br>链表中的的结点定义如下：</li></ol><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">node</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">int</span> data<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span>NODE<span class="token punctuation">;</span></pre></td></tr></table></figure><p>要求：<br>1、给出算法的基本设计思想</p><p>2、根据设计思想，采用 C 或 C++ 描述算法，关键之处给出注释</p><p>3、说明你所涉及算法的时间复杂度</p><p></p><div class="links"><div class="item" title="leetcode" style="--block-color:#556B2F"><span class="exturl image" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9MR2pNcVUv" data-background-image="//cdn.jsdelivr.net/gh/zhu-jiyuan/zhu-jiyuan.github.io@latest/images/404.png"></span><div class="info"><span class="exturl title" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9MR2pNcVUv">leetcode</span><p class="desc">本题对应leetcode</p></div></div><div class="item" title="leetcode" style="--block-color:#556B2F"><span class="exturl image" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9VSG5rcWgv" data-background-image="//cdn.jsdelivr.net/gh/zhu-jiyuan/zhu-jiyuan.github.io@latest/images/404.png"></span><div class="info"><span class="exturl title" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9VSG5rcWgv">leetcode</span><p class="desc">逆序链表</p></div></div><div class="item" title="leetcode" style="--block-color:#556B2F"><span class="exturl image" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taWRkbGUtb2YtdGhlLWxpbmtlZC1saXN0Lw==" data-background-image="//cdn.jsdelivr.net/gh/zhu-jiyuan/zhu-jiyuan.github.io@latest/images/404.png"></span><div class="info"><span class="exturl title" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taWRkbGUtb2YtdGhlLWxpbmtlZC1saXN0Lw==">leetcode</span><p class="desc">链表中间结点</p></div></div></div><p></p><details class="primary"><summary>答案</summary><div><p>因为限制了空间复杂度，大大滴加大了本题难度，比较综合了。<br>先说最佳方法<br>时间复杂度 O (n)</p><p>1、先找出链表的 <code>中间结点</code><br>例如：<br><span class="pink">1-&gt;2-&gt;3-&gt;4</span> 中间结点为 3<br><span class="pink">1-&gt;2-&gt;3-&gt;4-&gt;5</span> 中间结点为 3</p><p>2、再逆序中间之后的结点<br><span class="pink">1-&gt;2-&gt;3-&gt;4</span> 中间结点为 3<br>逆序之后<br>1-&gt;2-&gt;<span class="pink">4-&gt;3</span></p><p>3、再合并两部分结点<br>1-&gt;2<br>4-&gt;3<br>合并 1-&gt;4-&gt;2-&gt;3<br>合并代码思路，创建一个空结点 ans 表示当前位置，插入第一个链表的元素，更新 ans 和链表一当前结点的位置，再插入第二个链表的元素，更新 ans 和链表二当前结点的位置。直到链表二当前为 nullptr。结束循环，结束后，链表一可能还有一个元素，如果有直接插入，最后把末尾结点的 next 指向 nullptr。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num="2"></td><td><pre> * Definition for singly-linked list.</pre></td></tr><tr><td data-num="3"></td><td><pre> * struct ListNode &#123;</pre></td></tr><tr><td data-num="4"></td><td><pre> *     int val;</pre></td></tr><tr><td data-num="5"></td><td><pre> *     ListNode *next;</pre></td></tr><tr><td data-num="6"></td><td><pre> *     ListNode() : val(0), next(nullptr) &#123;&#125;</pre></td></tr><tr><td data-num="7"></td><td><pre> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</pre></td></tr><tr><td data-num="8"></td><td><pre> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</pre></td></tr><tr><td data-num="9"></td><td><pre> * &#125;;</pre></td></tr><tr><td data-num="10"></td><td><pre> */</pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">reorderList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token operator">||</span>head<span class="token operator">-></span>next<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        ListNode <span class="token operator">*</span>p1<span class="token punctuation">,</span><span class="token operator">*</span>p2<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        p1 <span class="token operator">=</span> head<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        p2 <span class="token operator">=</span> head<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token comment">// 先找中间位置</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token comment">//p1 每次走一个结点，p2 每次走俩结点，当 p2 走到终点，此时 p1 的位置就是中间位置</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token keyword">while</span><span class="token punctuation">(</span>p2<span class="token operator">!=</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            p1 <span class="token operator">=</span> p1<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            p2 <span class="token operator">=</span> p2<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>            <span class="token keyword">if</span><span class="token punctuation">(</span>p2<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>            p2 <span class="token operator">=</span> p2<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token comment">// 翻转 p1 之后的结点</span></pre></td></tr><tr><td data-num="29"></td><td><pre></pre></td></tr><tr><td data-num="30"></td><td><pre>        ListNode <span class="token operator">*</span> h <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        ListNode <span class="token operator">*</span> cur <span class="token operator">=</span> p1<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token comment">// 头插法翻转链表</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        p1<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>        <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token operator">!=</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>            ListNode <span class="token operator">*</span>t <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>            cur<span class="token operator">-></span>next<span class="token operator">=</span> h<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>            h<span class="token operator">-></span>next <span class="token operator">=</span> cur<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>            cur <span class="token operator">=</span> t<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="40"></td><td><pre></pre></td></tr><tr><td data-num="41"></td><td><pre>        h <span class="token operator">=</span> h<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="42"></td><td><pre>        <span class="token comment">// 合并链表</span></pre></td></tr><tr><td data-num="43"></td><td><pre>        ListNode<span class="token operator">*</span> p <span class="token operator">=</span> head<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="44"></td><td><pre>        ListNode <span class="token operator">*</span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="45"></td><td><pre>        <span class="token keyword">while</span><span class="token punctuation">(</span>h<span class="token operator">!=</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="46"></td><td><pre>            ans<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="47"></td><td><pre>            ans<span class="token operator">=</span>ans<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="48"></td><td><pre>            p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="49"></td><td><pre>            ans<span class="token operator">-></span>next <span class="token operator">=</span> h<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="50"></td><td><pre>            ans<span class="token operator">=</span>ans<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="51"></td><td><pre>            h<span class="token operator">=</span>h<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="52"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="53"></td><td><pre>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="54"></td><td><pre>            ans<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="55"></td><td><pre>            ans<span class="token operator">=</span>ans<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="56"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="57"></td><td><pre>        ans<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="58"></td><td><pre></pre></td></tr><tr><td data-num="59"></td><td><pre>        </pre></td></tr><tr><td data-num="60"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="61"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure></div></details><div class="tags"><a href="/tags/note/" rel="tag"><i class="ic i-tag"></i> note</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-08-24 17:48:19" itemprop="dateModified" datetime="2022-08-24T17:48:19+08:00">2022-08-24</time> </span><span id="2022/08/23/CS/dataStruct/linearTable/chainTable/" class="item leancloud_visitors" data-flag-title="数据结构-链表" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="//cdn.jsdelivr.net/gh/zhu-jiyuan/zhu-jiyuan.github.io@latest/images/wechatpay.png" alt="Gloria 微信支付"><p>微信支付</p></div><div><img data-src="//cdn.jsdelivr.net/gh/zhu-jiyuan/zhu-jiyuan.github.io@latest/images/alipay.png" alt="Gloria 支付宝"><p>支付宝</p></div><div><img data-src="//cdn.jsdelivr.net/gh/zhu-jiyuan/zhu-jiyuan.github.io@latest/images/paypal.png" alt="Gloria 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Gloria <i class="ic i-at"><em>@</em></i>北纬23</li><li class="link"><strong>本文链接：</strong> <a href="https://blog.ohayo.live/2022/08/23/CS/dataStruct/linearTable/chainTable/" title="数据结构-链表">https://blog.ohayo.live/2022/08/23/CS/dataStruct/linearTable/chainTable/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/08/18/CS/dataStruct/base/timeCalculate/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclimtf7dj20zk0m8qav.jpg" title="时间复杂度-练习题"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 数据结构</span><h3>时间复杂度-练习题</h3></a></div><div class="item right"><a href="/2022/08/25/CS/dataStruct/stackQueueArray/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giciukx8a7j20zk0m8aio.jpg" title="栈、队列和数组"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 数据结构</span><h3>栈、队列和数组</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%A8%E8%9B%8B%E9%93%BE%E8%A1%A8_"><span class="toc-number">1.</span> <span class="toc-text">笨蛋链表 &gt;_&lt;</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%BE%85%E8%A1%A5%E5%85%85%EF%B8%8F"><span class="toc-number">2.</span> <span class="toc-text">链表的基本操作 (待补充✏️</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%83%E4%B9%A0%E9%A2%98"><span class="toc-number">3.</span> <span class="toc-text">链表的练习题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%80%83%E7%A0%94%E5%9B%9B%E8%BF%9E%E4%B9%8B%E5%8B%A4%E4%BF%AD%E8%8A%82%E7%BA%A6"><span class="toc-number">3.1.</span> <span class="toc-text">考研四连之勤俭节约</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2022/08/18/CS/dataStruct/linearTable/olderTable/" rel="bookmark" title="数据结构-顺序表">数据结构-顺序表</a></li><li><a href="/2022/08/18/CS/dataStruct/base/timeCalculate/" rel="bookmark" title="时间复杂度-练习题">时间复杂度-练习题</a></li><li class="active"><a href="/2022/08/23/CS/dataStruct/linearTable/chainTable/" rel="bookmark" title="数据结构-链表">数据结构-链表</a></li><li><a href="/2022/08/25/CS/dataStruct/stackQueueArray/" rel="bookmark" title="栈、队列和数组">栈、队列和数组</a></li><li><a href="/2022/08/29/CS/dataStruct/stringAndKMP/" rel="bookmark" title="字符串匹配">字符串匹配</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Gloria" data-src="//cdn.jsdelivr.net/gh/zhu-jiyuan/zhu-jiyuan.github.io@latest/images/avatar.jpg"><p class="name" itemprop="name">Gloria</p><div class="description" itemprop="description">满怀勇敢</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">19</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">14</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">10</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3podS1qaXl1YW4=" title="https:&#x2F;&#x2F;github.com&#x2F;zhu-jiyuan"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9EaXZpZDJtYXRyaXg=" title="https:&#x2F;&#x2F;twitter.com&#x2F;Divid2matrix"><i class="ic i-twitter"></i></span> <span class="exturl item email" data-url="bWFpbHRvOmhjeUBvaGF5by5saXZl" title="mailto:hcy@ohayo.live"><i class="ic i-envelope"></i></span> <span class="exturl item youtube" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vY2hhbm5lbC9VQ2VfOVk3Y0RET29naFNQclFjN3RtQ3c=" title="https:&#x2F;&#x2F;www.youtube.com&#x2F;channel&#x2F;UCe_9Y7cDDOoghSPrQc7tmCw"><i class="ic i-youtube"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/08/18/CS/dataStruct/base/timeCalculate/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/08/25/CS/dataStruct/stackQueueArray/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/CS/" title="分类于 CS">CS</a> <i class="ic i-angle-right"></i> <a href="/categories/CS/machine-learning/" title="分类于 machine learning">machine learning</a></div><span><a href="/2022/04/18/CS/machine-learning-9-week/" title="machine learning 9周学习">machine learning 9周学习</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/soft/" title="分类于 soft">soft</a></div><span><a href="/2022/05/04/soft/quantumultx/quantumult-x-note/" title="Quantumult X一款神奇的软件">Quantumult X一款神奇的软件</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CS/" title="分类于 CS">CS</a> <i class="ic i-angle-right"></i> <a href="/categories/CS/python/" title="分类于 python">python</a></div><span><a href="/2022/08/12/CS/python/pyinstallerPacketExe/" title="pyinstaller打包exe">pyinstaller打包exe</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CS/" title="分类于 CS">CS</a> <i class="ic i-angle-right"></i> <a href="/categories/CS/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="分类于 数据结构">数据结构</a></div><span><a href="/2022/08/23/CS/dataStruct/linearTable/chainTable/" title="数据结构-链表">数据结构-链表</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CS/" title="分类于 CS">CS</a> <i class="ic i-angle-right"></i> <a href="/categories/CS/cpp/" title="分类于 cpp">cpp</a></div><span><a href="/2022/04/19/CS/cpp/c-five-zone/" title="c++的四大区">c++的四大区</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/leetcode/" title="分类于 leetcode">leetcode</a> <i class="ic i-angle-right"></i> <a href="/categories/leetcode/%E5%8D%95%E8%B0%83%E6%A0%88/" title="分类于 单调栈">单调栈</a></div><span><a href="/2022/08/30/leetcode/monotonousStack/" title="单调栈">单调栈</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CS/" title="分类于 CS">CS</a> <i class="ic i-angle-right"></i> <a href="/categories/CS/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="分类于 数据结构">数据结构</a></div><span><a href="/2022/08/18/CS/dataStruct/linearTable/olderTable/" title="数据结构-顺序表">数据结构-顺序表</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CS/" title="分类于 CS">CS</a> <i class="ic i-angle-right"></i> <a href="/categories/CS/Linux/" title="分类于 Linux">Linux</a></div><span><a href="/2022/01/05/CS/linux/CustomServerInit/" title="科学上网&amp;基本的网络服务器&amp;内网穿透">科学上网&基本的网络服务器&内网穿透</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CS/" title="分类于 CS">CS</a> <i class="ic i-angle-right"></i> <a href="/categories/CS/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="分类于 数据结构">数据结构</a></div><span><a href="/2022/08/29/CS/dataStruct/stringAndKMP/" title="字符串匹配">字符串匹配</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/apple/" title="分类于 apple">apple</a></div><span><a href="/2022/05/01/write/appleShortCuts/" title="苹果快捷指令">苹果快捷指令</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2020 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-Gloria"></i> </span><span class="author" itemprop="copyrightHolder">Gloria @ Gloria's notion</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">50k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">45 分钟</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/08/23/CS/dataStruct/linearTable/chainTable/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,copy_tex:!0,katex:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',quiz:{choice:"单选题",multiple:"多选题",true_false:"判断题",essay:"问答题",gap_fill:"填空题",mistake:"错题备注"},ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="//cdn.jsdelivr.net/gh/zhu-jiyuan/zhu-jiyuan.github.io@latest/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->